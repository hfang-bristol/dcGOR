% Generated by roxygen2 (4.0.1): do not edit by hand
\name{dcAncestralMP}
\alias{dcAncestralMP}
\title{Function to reconstruct ancestral discrete states using maximum parsimony algorithm}
\usage{
dcAncestralMP(x, phy, verbose = T)
}
\arguments{
\item{x}{a vector of discrete states in the tips. It can be an unnamed
vector; in this case, assumedly it has the same order as in the tree
tips. More wisely, it is a named vector, whose names can be matched to
the tip labels of the tree. The names of this input vector can be more
than found in the tree labels, and they should contain all those in the
tree labels}

\item{phy}{an object of class 'phylo'}

\item{verbose}{logical to indicate whether the messages will be
displayed in the screen. By default, it sets to TRUE for display}
}
\value{
a list of architectures, containing three components for "transition",
"states" and "rp":
\itemize{
\item{\code{transition}: a posterior transition matrix between states}
\item{\code{states}: a named vector storing states (extant and
ancestral states)}
\item{\code{rp}: a matrix of nodes X states, storing relative
probability}
}
}
\description{
\code{dcAncestralMP} is supposed to reconstruct ancestral discrete
states using a maximum parsimony-modified Fitch algorithm. In a
bottom-up manner, ancestral state for an internal node is determined if
a state is shared in a majority by all its children. If two or more
states in a majority are equally shared, this internal node is marked
as unknown tie. For those ties, they are resolved being the same as its
direct parent in a top-down manner. If the tie also occurs at the root,
the state at the root is set to the last state (for example, 'present'
for 2 states).
}
\note{
This maximum parsimony algorithm for ancestral discrete state
reconstruction is attributable to the basic idea as described in
\url{http://sysbio.oxfordjournals.org/content/20/4/406.short}
}
\examples{
# provide the tree and states in the tips
tree <-
"((((t10:5.03,t2:5.03):2.74,(t9:4.17,t5:4.17):3.60):2.80,(t3:4.05,t7:4.05):6.53):2.32,((t6:4.38,t1:4.38):2.18,(t8:2.17,t4:2.17):4.39):6.33);"
phy <- ape::read.tree(text=paste(tree, collapse=""))
x <- c(0, rep(1,4), rep(0,5))

# reconstruct ancestral states
res <- dcAncestralMP(x, phy)
res

# visualise the tree with ancestral states and their conditional probability
Ntip <- ape::Ntip(phy)
Nnode <- ape::Nnode(phy)
color <- c("white","gray")
## main tree
ape::plot.phylo(phy, type="p", use.edge.length=TRUE, label.offset=1,
show.tip.label=TRUE, show.node.label=FALSE)
## tips
ape::tiplabels(pch=22, bg=color[as.numeric(x)+1], cex=2, adj=1)
## internal nodes
### relative probability
ape::nodelabels(thermo=res$relative[Ntip+1:Nnode,2:1],
piecol=color[2:1], cex=0.75)
### ancestral states
ape::nodelabels(text=res$states[Ntip+1:Nnode], node=Ntip+1:Nnode,
frame="none", col="red", bg="transparent", cex=0.75)
#ape::nodelabels(text=phy$node.label, node=Ntip+1:Nnode, frame="none", col="red", bg="transparent", cex=0.75)
}
\seealso{
\code{\link{dcAncestralMP}}
}

