% Generated by roxygen2 (4.0.1): do not edit by hand
\name{dcAncestralMP}
\alias{dcAncestralMP}
\title{Function to reconstruct ancestral discrete states using maximum parsimony algorithm}
\usage{
dcAncestralMP(x, phy, verbose = T)
}
\arguments{
\item{x}{a vector of discrete states in the tips. It can be an unnamed
vector; in this case, assumedly it has the same order as in the tree
tips. More wisely, it is a named vector, whose names can be matched to
the tip labels of the tree. The names of this input vector can be more
than found in the tree labels, and they should contain all those in the
tree labels}

\item{phy}{an object of class 'phylo'}

\item{verbose}{logical to indicate whether the messages will be
displayed in the screen. By default, it sets to TRUE for display}
}
\value{
a list of architectures, containing three components for "transition",
"states" and "relative":
\itemize{
\item{\code{transition}: a posterior transition matrix between states}
\item{\code{states}: a named vector storing states (extant and
ancestral states)}
\item{\code{relative}: a matrix of nodes X states, storing relative
probability}
}
}
\description{
\code{dcAncestralMP} is supposed to reconstruct ancestral discrete
states using a maximum parsimony-modified Fitch algorithm. In a
from-tip-to-root manner, ancestral state for an internal node is
determined if a state is shared in a majority by all its children. If
two or more states in a majority are equally shared, this internal node
is temporarily marked as an unknown tie, which is further resolved in a
from-root-to-tip manner: always being the same state as its direct
parent holds. If the ties also occur at the root, the state at the root
is set to the last state in ties (for example, usually being 'present'
for 'present'-'absent' two states).
}
\note{
This maximum parsimony algorithm for ancestral discrete state
reconstruction is attributable to the basic idea as described in
\url{http://sysbio.oxfordjournals.org/content/20/4/406.short}
}
\examples{
# provide the tree and states in the tips
tree <-
"((((t10:5,t2:5):2,(t9:4,t5:4):3):2,(t3:4,t7:4):6):2,((t6:4,t1:4):2,(t8:2,t4:2):4):6);"
phy <- ape::read.tree(text=paste(tree, collapse=""))
x <- c(0, rep(1,4), rep(0,5))

# reconstruct ancestral states
res <- dcAncestralMP(x, phy)
res

# visualise the tree with ancestral states and their conditional probability
Ntip <- ape::Ntip(phy)
Nnode <- ape::Nnode(phy)
color <- c("white","gray")
## visualise main tree
ape::plot.phylo(phy, type="p", use.edge.length=TRUE, label.offset=1,
show.tip.label=TRUE, show.node.label=FALSE)
## visualise tips (state 1 in gray, state 0 in white)
ape::tiplabels(pch=22, bg=color[as.numeric(x)+1], cex=2, adj=1)
## visualise internal nodes
### thermo bar to illustrate relative probability (state 1 in gray, state 0 in white)
ape::nodelabels(thermo=res$relative[Ntip+1:Nnode,2:1],
piecol=color[2:1], cex=0.75)
### labeling reconstructed ancestral states
ape::nodelabels(text=res$states[Ntip+1:Nnode], node=Ntip+1:Nnode,
frame="none", col="red", bg="transparent", cex=0.75)
}
\seealso{
\code{\link{dcAncestralML}}
}

